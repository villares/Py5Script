<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Runner</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        main { display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        // Catch global JS errors (including PythonError from Pyodide)
        window.addEventListener('error', function(event) {
            if (event.error && event.error.message) {
                 const msg = { type: 'error', message: event.error.message };
                 window.parent.postMessage(msg, '*');
            } else {
                 // Fallback for string errors
                 const msg = { type: 'error', message: event.message || String(event) };
                 window.parent.postMessage(msg, '*');
            }
        });

        // Catch unhandled promise rejections (often used by async Pyodide)
        window.addEventListener('unhandledrejection', function(event) {
            const msg = { type: 'error', message: "Unhandled Rejection: " + (event.reason ? event.reason.message || event.reason : "Unknown") };
            window.parent.postMessage(msg, '*');
        });
    </script>
    <script type="py">
        import js
        import ast
        import textwrap
        import sys
        import json
        import base64
        from pyodide.ffi import create_proxy, to_js

        # Global p5 instance
        p5 = None

        class StdoutCatcher:
            def write(self, text):
                msg = {"type": "print", "message": text}
                js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
            def flush(self):
                pass
        
        class StderrCatcher:
            def write(self, text):
                msg = {"type": "error", "message": text}
                js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
            def flush(self):
                pass

        # Install Catchers globally immediately
        sys.stdout = StdoutCatcher()
        sys.stderr = StderrCatcher()

        def camel_to_snake(name):
            import re
            s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
            return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

        class P5Transformer(ast.NodeTransformer):
            def __init__(self, user_defined, case_mode='both'):
                # Use prototype to get properties since instance isn't created yet
                self.p5_props = set(dir(js.p5.prototype))
                self.user_defined = user_defined
                self.case_mode = case_mode
                self.scope_stack = []

                # Explicitly exclude 'print' and other builtins/globals

                exclusions = {'print', 'open', 'exit', 'quit', 'help', 'asset'}
                self.p5_props -= exclusions
                
                self.p5_props.add('drawingContext')
                
                # Build Mapping: snake_case -> camelCase
                # Only needed if case_mode is 'snake' or 'both'
                self.snake_map = {}
                if self.case_mode in ['snake', 'both']:
                    for prop in self.p5_props:
                        snake = camel_to_snake(prop)
                        # Ensure we don't map back to an excluded builtin (e.g. OPEN -> open)
                        if snake != prop and snake not in exclusions:
                            self.snake_map[snake] = prop

            def resolve_p5_name(self, name):
                # 0. Check Scope Stack (Local shadowing)
                for scope in self.scope_stack:
                    if name in scope:
                        return None
                        
                # 1. Check exact match (CamelCase)
                if name in self.p5_props:
                    if self.case_mode in ['camel', 'both']:
                        return name
                    if self.case_mode == 'snake':
                        return None 

                # 2. Check snake_case match
                if name in self.snake_map:
                    if self.case_mode in ['snake', 'both']:
                        return self.snake_map[name]
                
                return None
            
            def analyze_scope(self, node):
                """Collect local variables from a function body (args + assignments)"""
                local_vars = set()
                
                # 1. Arguments
                for arg in node.args.args:
                    local_vars.add(arg.arg)
                
                # 2. Body assignments
                for child in node.body:
                    if isinstance(child, ast.Assign):
                        for target in child.targets:
                            if isinstance(target, ast.Name):
                                local_vars.add(target.id)
                            # Tuple unpacking? (a, b) = ...
                            elif isinstance(target, ast.Tuple) or isinstance(target, ast.List):
                                for elt in target.elts:
                                    if isinstance(elt, ast.Name):
                                        local_vars.add(elt.id)
                    elif isinstance(child, ast.AnnAssign):
                         if isinstance(child.target, ast.Name):
                             local_vars.add(child.target.id)
                    elif isinstance(child, ast.For):
                        if isinstance(child.target, ast.Name):
                            local_vars.add(child.target.id)
                        elif isinstance(child.target, ast.Tuple):
                            for elt in child.target.elts:
                                if isinstance(elt, ast.Name):
                                    local_vars.add(elt.id)
                return local_vars

            def visit_FunctionDef(self, node):
                # Push new scope
                local_names = self.analyze_scope(node)
                self.scope_stack.append(local_names)
                
                # Visit children (body)
                self.generic_visit(node)
                
                # Pop scope
                self.scope_stack.pop()
                return node

            def visit_Call(self, node):
                # We do generic_visit first to process arguments
                self.generic_visit(node)
                
                if isinstance(node.func, ast.Name):
                    name = node.func.id
                    if name == 'print': return node
                    
                    if name not in self.user_defined:
                        target = self.resolve_p5_name(name)
                        if target:
                            node.func = ast.Attribute(
                                value=ast.Name(id='p5', ctx=ast.Load()),
                                attr=target,
                                ctx=ast.Load()
                            )
                return node

            def visit_Name(self, node):
                if isinstance(node.ctx, ast.Load):
                    if node.id not in self.user_defined:
                         target = self.resolve_p5_name(node.id)
                         if target:
                            return ast.Attribute(
                                value=ast.Name(id='p5', ctx=ast.Load()),
                                attr=target,
                                ctx=ast.Load()
                            )
                return node

        def entry_point():
            # Standard file IO is sufficient in Pyodide
            import os
            import importlib.abc
            import importlib.util
            
            # Ensure stdout is still set
            sys.stdout = StdoutCatcher()
            
            # Parse URL params for case-mode (Global setting)
            params = js.URLSearchParams.new(js.window.location.search)
            case_mode = params.get('case')
            if not case_mode:
                case_mode = 'both'

            # --- Custom Import Hook for Auto-Prefixing in Modules ---
            class P5Importer(importlib.abc.MetaPathFinder, importlib.abc.Loader):
                def __init__(self, mode):
                    self.mode = mode

                def find_spec(self, fullname, path, target=None):
                    filename = fullname + ".py"
                    if os.path.exists(filename):
                        return importlib.util.spec_from_file_location(fullname, filename, loader=self)
                    return None

                def create_module(self, spec):
                    return None 

                def exec_module(self, module):
                    with open(module.__file__, 'r') as f:
                        source = f.read()
                    
                    try:
                        tree = ast.parse(source)
                    except Exception as e:
                        print(f"SyntaxError in {module.__name__}: {e}")
                        raise e

                    user_defined = set()
                    for node in tree.body:
                        if isinstance(node, ast.FunctionDef):
                            user_defined.add(node.name)
                        elif isinstance(node, ast.Assign):
                            for target in node.targets:
                                if isinstance(target, ast.Name):
                                    user_defined.add(target.id)
                                elif isinstance(target, ast.Tuple) or isinstance(target, ast.List):
                                    for elt in target.elts:
                                        if isinstance(elt, ast.Name):
                                            user_defined.add(elt.id)
                    
                    transformer = P5Transformer(user_defined, self.mode)
                    new_tree = transformer.visit(tree)
                    ast.fix_missing_locations(new_tree)
                    
                    code_obj = compile(new_tree, filename=module.__file__, mode="exec")
                    exec(code_obj, module.__dict__)

            # Register Hook
            sys.meta_path.insert(0, P5Importer(case_mode))

            # --- Unified Project Hydration ---
            # All files (code + assets) are in 'py5script_project'
            hydrated_assets = {}
            try:
                project_json = js.localStorage.getItem('py5script_project')
                if project_json:
                    project_files = json.loads(project_json)
                    for filename, content in project_files.items():
                        try:
                            # Check if Data URL (Binary/Asset)
                            if content.startswith('data:'):
                                # Decode Data URL
                                # Format: data:[mime];base64,[data]
                                if ',' in content:
                                    _, headerless_data = content.split(',', 1)
                                    binary_data = base64.b64decode(headerless_data)
                                    
                                    # Write to FS
                                    with open(filename, 'wb') as f:
                                        f.write(binary_data)
                                    
                                    # Add to hydration map for p5 interceptors
                                    hydrated_assets[filename] = content
                            else:
                                # Regular Text File (Module)
                                with open(filename, 'w') as f:
                                    f.write(content)
                        except Exception as inner_e:
                            # print(f"Error hydrating {filename}: {inner_e}")
                            pass
            except Exception as e:
                pass
            # -----------------------

            # Asset Helper (Explicit URL resolution)
            def asset(filename):
                """
                Returns the Data URL for a given asset filename if it exists.
                Otherwise returns the filename itself (fallback).
                Usage: p5.loadImage(asset('cat.png'))
                """
                if filename in hydrated_assets:
                    return hydrated_assets[filename]
                return filename
            
            # Expose to global scope for user scripts
            globals()['asset'] = asset
            # Ensure open is builtins.open (defensive)
            import builtins
            globals()['open'] = builtins.open



            def sketch(p):
                global p5
                p5 = p
                # Inject p5 into builtins so imported modules can access it as 'p5'
                import builtins
                builtins.p5 = p  
                
                # Intercept load functions to use Data URLs if available
                # This fixes p5.loadImage() failing to fetch local files
                def create_asset_loader(original_loader, loader_name):
                    def wrapper(path, *args, **kwargs):
                        # If path is in our assets, swap it with the Data URL
                        if isinstance(path, str) and path in hydrated_assets:
                             # js.console.log(f"DEBUG: Intercepting {loader_name}('{path}') -> Serving Data URL")
                             return original_loader(hydrated_assets[path], *args, **kwargs)
                        return original_loader(path, *args, **kwargs)
                    return wrapper

                # List of load functions to wrap
                load_funcs = ['loadImage', 'loadJSON', 'loadStrings', 'loadTable', 'loadXML', 'loadBytes', 'loadModel', 'loadFont', 'loadSound']
                for name in load_funcs:
                    if hasattr(p, name):
                         original = getattr(p, name)
                         setattr(p, name, create_proxy(create_asset_loader(original, name)))

                # 1. Get Code & Params
                raw_source = js.window.name
                source = textwrap.dedent(raw_source)
                

                
                if not source.strip(): return

                try:
                    tree = ast.parse(source)
                except Exception as e:
                    # Captura erro de sintaxe
                    err_msg = f"{e.__class__.__name__}: {e}"
                    line_num = getattr(e, 'lineno', 0)
                    msg = {"type": "error", "message": err_msg, "line": line_num}
                    js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                    return

                # Collect user definitions
                user_defined = set()
                for node in tree.body:
                    if isinstance(node, ast.FunctionDef):
                        user_defined.add(node.name)
                    elif isinstance(node, ast.Assign):
                        for target in node.targets:
                            if isinstance(target, ast.Name):
                                user_defined.add(target.id)

                # 2. Transform AST
                transformer = P5Transformer(user_defined, case_mode)
                new_tree = transformer.visit(tree)
                ast.fix_missing_locations(new_tree)

                # 3. Compile and Execute
                try:
                    code_obj = compile(new_tree, filename="<student_code>", mode="exec")
                    exec(code_obj, globals())
                except Exception as e:
                    import traceback
                    tb_list = traceback.extract_tb(e.__traceback__)
                    line_num = 0
                    for frame in tb_list:
                        if frame.filename == "<student_code>":
                            line_num = frame.lineno
                    
                    err_msg = f"{e.__class__.__name__}: {e}"
                    msg = {"type": "error", "message": err_msg, "line": line_num}
                    js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                    return
                
                # 4. Connect to p5
                # List of p5.js event functions to map
                p5_events = [
                    'setup', 'draw', 'preload',
                    'mousePressed', 'mouseReleased', 'mouseClicked', 'mouseMoved', 'mouseDragged', 'doubleClicked', 'mouseWheel',
                    'keyPressed', 'keyReleased', 'keyTyped',
                    'touchStarted', 'touchMoved', 'touchEnded',
                    'deviceMoved', 'deviceTurned', 'deviceShaken',
                    'windowResized'
                ]
                
                import inspect
                import traceback

                def safe_wrapper(func):
                    def wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        except Exception:
                            traceback.print_exc() 
                            # We catch it, print it to our console, and suppress it from bubbling to JS console as an ugly Error
                            # OR we re-raise? If we suppress, the sketch continues running (maybe bad state).
                            # If we re-raise, it goes to JS console too. 
                            # Let's just print. P5 might keep looping draw() though.
                    return wrapper

                def create_arg_stripper(func):
                    return lambda *args: func()

                for event in p5_events:
                    py_func = None
                    
                    # 1. Check for standard camelCase (mousePressed)
                    if event in globals():
                        py_func = globals()[event]
                        
                    # 2. Check for snake_case (mouse_pressed)
                    else:
                        snake_event = camel_to_snake(event)
                        if snake_event != event and snake_event in globals():
                            py_func = globals()[snake_event]
                    
                    if py_func:
                        # Handle argument mismatch (e.g. mousePressed(e) vs mousePressed())
                        if callable(py_func):
                             try:
                                 sig = inspect.signature(py_func)
                                 params = sig.parameters
                                 has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params.values())
                                 
                                 if not has_varargs and len(params) == 0:
                                      # Wrap to discard arguments
                                      py_func = create_arg_stripper(py_func)
                             except Exception as e:
                                 pass

                        # Wrap in error handler
                        secure_func = safe_wrapper(py_func)
                        setattr(p, event, create_proxy(secure_func))

            proxy = create_proxy(sketch)
            js.window.p5.new(proxy)

        entry_point()
    </script>
</body>
</html>
