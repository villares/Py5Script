<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Runner</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        main { display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        // Catch global JS errors (including PythonError from Pyodide)
        window.addEventListener('error', function(event) {
            let message = "";
            if (event.error && event.error.message) {
                 message = event.error.message;
            } else {
                 message = event.message || String(event);
            }
            
            // Ignore duplicate SyntaxErrors (handled by Python logic)
            if (message && message.includes('SyntaxError:')) return;

            const msg = { type: 'error', message: message };
            window.parent.postMessage(msg, '*');
        });

        // Catch unhandled promise rejections (often used by async Pyodide)
        window.addEventListener('unhandledrejection', function(event) {
            const message = (event.reason ? event.reason.message || event.reason : "Unknown");
            if (message && message.toString().includes('SyntaxError:')) return;

            const msg = { type: 'error', message: "Unhandled Rejection: " + message };
            window.parent.postMessage(msg, '*');
        });

        // Intercept console.error (used by p5.js for shader/internal errors)
        (function() {
            const originalError = console.error;
            console.error = function(...args) {
                originalError.apply(console, args);
                
                // Convert args to string message
                const message = args.map(arg => String(arg)).join(' ');
                
                // Post to IDE
                window.parent.postMessage({ type: 'error', message: message }, '*');

                // Stop Sketch if it's running (prevents infinite error loops)
                // We access the global P5 instance from the Python side if possible, 
                // but simpler to check the global variable directly if exposed to JS or just known.
                // Logic: "P5" is defined in Python `globals()`, not necessarily window.
                // BUT, we can try to stop p5 via the instance assigned to window.p5 if we can reach it.
                // Actually, the instance is inside `sketch` function scope. 
                // However, `P5` is global in Python. 
                // Let's use a try-catch to call back into Python? Or just accept that `noLoop` might be hard to reach from here?
                // Wait, we can't easily reach Python state from this JS block.
                // BUT we can check `window.p5` which is the constructor. The instance?
                // We don't have a global reference to the p5 instance in JS scope (it's in Python).
                
                // Workaround: We can post a message that *Python* listens to? No.
                // We can't easily stop it from here unless we exposed the instance to window.
                // Let's rely on the user manually stopping?
                // NO, user requested "stop the execution".
                
                // Solution: In `sketch()` function (Python), we set `js.window.currentP5 = p`.
                if (window.currentP5) {
                    try { window.currentP5.noLoop(); } catch(e){}
                }
            };
        })();
    </script>
    <script type="py">
        import js
        import ast
        import textwrap
        import sys
        import json
        import base64
        import asyncio
        from pyodide.ffi import create_proxy, to_js

        # Global P5 instance
        P5 = None
        # Expose global p5 class
        p5 = js.p5

        class StdoutCatcher:
            def write(self, text):
                msg = {"type": "print", "message": text}
                js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
            def flush(self):
                pass
        
        class StderrCatcher:
            def write(self, text):
                # Avoid Duplicate SyntaxError messages (handled explicitly by sketch logic)
                if text.strip().startswith('SyntaxError:'):
                    return
                msg = {"type": "error", "message": text}
                js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
            def flush(self):
                pass

        # Install Catchers globally immediately
        sys.stdout = StdoutCatcher()
        sys.stderr = StderrCatcher()

        def camel_to_snake(name):
            if name.isupper(): return name
            import re
            s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
            return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

        class P5Transformer(ast.NodeTransformer):
            def __init__(self, user_defined, case_mode='both'):
                # Use prototype to get properties since instance isn't created yet
                self.p5_props = set(dir(js.p5.prototype))
                self.user_defined = user_defined
                self.case_mode = case_mode
                self.scope_stack = []

                # Explicitly exclude 'print' and other builtins/globals
                # 'label' is often leaked from p5.prototype (as part of internal DOM attributes?) causing confusion.
                exclusions = {
                    'print', 'open', 'exit', 'quit', 'help', 'asset', 'label',
                    'map', 'set', 'filter', 'min', 'max', 'abs', 'round', 'pow', 'sum',
                    'random', 'shuffle', 'sort', 'reverse', 'append', 'splice', 'subset', 
                    'join', 'split', 'shorten', 'concat'
                }
                self.p5_props -= exclusions
                
                self.p5_props.add('drawingContext')
                
                # Build Mapping: snake_case -> camelCase
                # Only needed if case_mode is 'snake' or 'both'
                self.snake_map = {}
                if self.case_mode in ['snake', 'both']:
                    for prop in self.p5_props:
                        snake = camel_to_snake(prop)
                        # Ensure we don't map back to an excluded builtin (e.g. OPEN -> open)
                        if snake != prop and snake not in exclusions:
                            self.snake_map[snake] = prop

            def resolve_p5_name(self, name):
                # 0. Check Scope Stack (Local shadowing)
                for scope in self.scope_stack:
                    if name in scope:
                        return None
                        
                # 1. Check exact match (CamelCase)
                if name in self.p5_props:
                    if self.case_mode in ['camel', 'both']:
                        return name
                    if self.case_mode == 'snake':
                        return None 

                # 2. Check snake_case match
                if name in self.snake_map:
                    if self.case_mode in ['snake', 'both']:
                        return self.snake_map[name]
                
                return None
            
            def analyze_scope(self, node):
                """Collect local variables from a function body (args + assignments), recursively."""
                local_vars = set()
                
                # 1. Arguments are always local
                for arg in node.args.args:
                    local_vars.add(arg.arg)
                
                # 2. Recursive traversal for assignments
                # We do NOT use generic_visit/NodeVisitor because we need manual control 
                # to STOP at nested scopes (FunctionDef, ClassDef, Lambda).
                
                def visit_node_scope(n):
                    if isinstance(n, ast.Assign):
                        for target in n.targets:
                            add_target(target)
                    elif isinstance(n, ast.AnnAssign):
                         add_target(n.target)
                    elif isinstance(n, ast.For) or isinstance(n, ast.AsyncFor):
                        add_target(n.target)
                        for item in n.body: visit_node_scope(item)
                        for item in n.orelse: visit_node_scope(item)
                    elif isinstance(n, ast.With) or isinstance(n, ast.AsyncWith):
                        for item in n.items:
                            if item.optional_vars:
                                add_target(item.optional_vars)
                        for item in n.body: visit_node_scope(item)
                    elif isinstance(n, ast.NamedExpr): # walrus operator (a := 1)
                        add_target(n.target)
                    
                    # Control Flow - Recurse but don't add vars directly
                    elif isinstance(n, (ast.If, ast.While, ast.Try)):
                        for field, value in ast.iter_fields(n):
                            if isinstance(value, list):
                                for item in value:
                                    if isinstance(item, ast.AST):
                                        visit_node_scope(item)
                            elif isinstance(value, ast.AST):
                                visit_node_scope(value)
                    
                    # Scopes - STOP recursion. 
                    # Nested functions/classes create their own scope, so their locals aren't ours.
                    elif isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Lambda)):
                        return 

                    # Statements - Recurse into lists of statements (like module body or if body)
                    elif hasattr(n, 'body') and isinstance(n.body, list):
                         for item in n.body:
                             visit_node_scope(item)

                def add_target(target):
                    if isinstance(target, ast.Name):
                        local_vars.add(target.id)
                    elif isinstance(target, (ast.Tuple, ast.List)):
                        for elt in target.elts:
                            add_target(elt)
                
                # Start traversal from function body
                for item in node.body:
                    visit_node_scope(item)
                    
                return local_vars

            def visit_FunctionDef(self, node):
                # Push new scope
                local_names = self.analyze_scope(node)
                self.scope_stack.append(local_names)
                
                # Visit children (body)
                self.generic_visit(node)
                
                # Pop scope
                self.scope_stack.pop()
                return node

            def visit_Call(self, node):
                # We do generic_visit first to process arguments
                self.generic_visit(node)
                
                if isinstance(node.func, ast.Name):
                    name = node.func.id
                    if name == 'print': return node
                    
                    if name not in self.user_defined:
                        target = self.resolve_p5_name(name)
                        if target:
                            node.func = ast.Attribute(
                                value=ast.Name(id='P5', ctx=ast.Load()),
                                attr=target,
                                ctx=ast.Load()
                            )
                return node

            def visit_Name(self, node):
                if isinstance(node.ctx, ast.Load):
                    if node.id not in self.user_defined:
                         target = self.resolve_p5_name(node.id)
                         if target:
                            return ast.Attribute(
                                value=ast.Name(id='P5', ctx=ast.Load()),
                                attr=target,
                                ctx=ast.Load()
                            )
                return node

        async def entry_point():
            # Standard file IO is sufficient in Pyodide
            import os
            import importlib.abc
            import importlib.util
            
            # Ensure stdout is still set
            sys.stdout = StdoutCatcher()
            
            # Parse URL params for case-mode (Global setting)
            params = js.URLSearchParams.new(js.window.location.search)
            case_mode = params.get('case')
            if not case_mode:
                case_mode = 'both'

            # --- Custom Import Hook for Auto-Prefixing in Modules ---
            class P5Importer(importlib.abc.MetaPathFinder, importlib.abc.Loader):
                def __init__(self, mode):
                    self.mode = mode

                def find_spec(self, fullname, path, target=None):
                    filename = fullname + ".py"
                    if os.path.exists(filename):
                        return importlib.util.spec_from_file_location(fullname, filename, loader=self)
                    return None

                def create_module(self, spec):
                    return None 

                def exec_module(self, module):
                    with open(module.__file__, 'r') as f:
                        source = f.read()
                    
                    try:
                        tree = ast.parse(source)
                    except Exception as e:
                        # Report SyntaxError in module
                        err_msg = f"{e.__class__.__name__}: {e}"
                        if isinstance(e, SyntaxError):
                            err_msg = f"{e.__class__.__name__}: {e.msg}"
                        
                        line_num = getattr(e, 'lineno', 0)
                        msg = {"type": "error", "message": err_msg, "filename": module.__file__, "line": line_num}
                        js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                        raise e

                    user_defined = set()
                    for node in tree.body:
                        if isinstance(node, ast.FunctionDef):
                            user_defined.add(node.name)
                        elif isinstance(node, ast.Assign):
                            for target in node.targets:
                                if isinstance(target, ast.Name):
                                    user_defined.add(target.id)
                                elif isinstance(target, ast.Tuple) or isinstance(target, ast.List):
                                    for elt in target.elts:
                                        if isinstance(elt, ast.Name):
                                            user_defined.add(elt.id)
                    
                    try:
                        transformer = P5Transformer(user_defined, self.mode)
                        new_tree = transformer.visit(tree)
                        ast.fix_missing_locations(new_tree)
                        
                        code_obj = compile(new_tree, filename=module.__file__, mode="exec")
                        exec(code_obj, module.__dict__)
                    except Exception as e:
                         # Runtime error in module execution
                        import traceback
                        # We just propagate it, but the main loop's handler might catch "ImportError",
                        # so we want to be sure to report the inner detail if possible.
                        # Actually, posting here is safe.
                        tb_list = traceback.extract_tb(e.__traceback__)
                        line_num = 0
                        err_filename = module.__file__
                        if tb_list:
                             last_frame = tb_list[-1]
                             line_num = last_frame.lineno
                             err_filename = last_frame.filename
                        
                        err_msg = f"{e.__class__.__name__}: {e}"
                        msg = {"type": "error", "message": err_msg, "filename": err_filename, "line": line_num}
                        js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                        raise e

            # Register Hook
            sys.meta_path.insert(0, P5Importer(case_mode))

            # --- Unified Project Hydration ---
            # Parse Project ID from runner URL
            params = js.URLSearchParams.new(js.window.location.search)
            project_id = params.get('id')
            
            hydrated_assets = {}
            try:
                project_json = None
                if project_id:
                     # New Scoped System
                     project_json = js.localStorage.getItem(f"project_{project_id}_files")
                else:
                     # Fallback to Legacy (shouldn't happen often)
                     project_json = js.localStorage.getItem('py5script_project')

                if project_json:
                    project_files = json.loads(project_json)
                    for filename, content in project_files.items():
                        try:
                            # Check if Data URL (Binary/Asset)
                            if content.startswith('data:'):
                                # Decode Data URL
                                # Format: data:[mime];base64,[data]
                                if ',' in content:
                                    _, headerless_data = content.split(',', 1)
                                    binary_data = base64.b64decode(headerless_data)
                                    
                                    # Write to FS
                                    with open(filename, 'wb') as f:
                                        f.write(binary_data)
                                    
                                    # Add to hydration map for p5 interceptors
                                    hydrated_assets[filename] = content
                            else:
                                # Regular Text File (Module)
                                with open(filename, 'w') as f:
                                    f.write(content)
                                
                                # Register as Data URL for p5 interceptors (loadStrings, loadShader)
                                # We treat all text-based assets as text/plain here for simplicity
                                b64_text = base64.b64encode(content.encode('utf-8')).decode('utf-8')
                                hydrated_assets[filename] = f"data:text/plain;base64,{b64_text}"
                        except Exception as inner_e:
                            # print(f"Error hydrating {filename}: {inner_e}")
                            pass
            except Exception as e:
                pass
            # -----------------------

            # --- Package Installation (requirements.txt) ---
            if os.path.exists("requirements.txt"):
                try:
                    # Ensure micropip is available
                    try:
                        import micropip
                    except ImportError:
                        # Attempt to load micropip via Pyodide JS API wrapper
                        try:
                            import pyodide_js
                            await pyodide_js.loadPackage("micropip")
                            import micropip
                        except Exception as e:
                             print(f"Error loading micropip: {e}")
                             raise e

                    with open("requirements.txt", "r") as f:
                        packages = [line.strip() for line in f if line.strip() and not line.startswith('#')]
                    
                    if packages:
                        print(f"Installing packages: {packages}...")
                        await micropip.install(packages)
                        print("Packages installed.")
                except Exception as e:
                    print(f"Error installing packages: {e}")
                    # Post error but maybe continue
                    msg = {"type": "error", "message": f"Failed to install requirements: {e}", "filename": "requirements.txt", "line": 0}
                    js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
            # ---------------------------------------------

            # Asset Helper (Explicit URL resolution)
            def asset(filename):
                """
                Returns the Data URL for a given asset filename if it exists.
                Otherwise returns the filename itself (fallback).
                Usage: p5.loadImage(asset('cat.png'))
                """
                if filename in hydrated_assets:
                    return hydrated_assets[filename]
                return filename
            
            # Expose to global scope for user scripts
            globals()['asset'] = asset
            # Ensure open is builtins.open (defensive)
            import builtins
            globals()['open'] = builtins.open

            # ------- py5 compatibility hacks ------------
            def remap(*args):
                return P5.map(*args)
            globals()['remap'] = remap

            def size(*args):
                P5.background(200)
                P5.fill('white')
                return P5.createCanvas(*args)
            globals()['size'] = size


            def sketch(p):
                global P5
                P5 = p
                # Expose to JS for console.error interception
                js.window.currentP5 = p
                
                # Inject P5 into builtins so imported modules can access it as 'P5'
                import builtins
                builtins.P5 = p
                builtins.p5 = js.p5 # Global p5 class available everywhere  
                
                # Intercept load functions to use Data URLs if available
                # This fixes p5.loadImage() failing to fetch local files
                def create_asset_loader(original_loader, loader_name):
                    def wrapper(*args, **kwargs):
                        new_args = []
                        for arg in args:
                            if isinstance(arg, str) and arg in hydrated_assets:
                                new_args.append(hydrated_assets[arg])
                            else:
                                new_args.append(arg)
                        return original_loader(*new_args, **kwargs)
                    return wrapper

                # List of load functions to wrap
                load_funcs = ['loadImage', 'loadJSON', 'loadStrings', 'loadTable', 'loadXML', 'loadBytes', 'loadModel', 'loadFont', 'loadSound', 'loadShader']
                for name in load_funcs:
                    if hasattr(p, name):
                         original = getattr(p, name)
                         setattr(p, name, create_proxy(create_asset_loader(original, name)))

                # 1. Get Code & Params
                raw_source = js.window.name
                source = textwrap.dedent(raw_source)
                

                
                if not source.strip(): return

                try:
                    tree = ast.parse(source)
                except Exception as e:
                    # Captura erro de sintaxe
                    err_msg = f"{e.__class__.__name__}: {e}"
                    if isinstance(e, SyntaxError):
                        err_msg = f"{e.__class__.__name__}: {e.msg}"
                    
                    line_num = getattr(e, 'lineno', 0)
                    msg = {"type": "error", "message": err_msg, "filename": "sketch.py", "line": line_num}
                    js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                    return

                # Collect user definitions
                user_defined = set()
                for node in tree.body:
                    if isinstance(node, ast.FunctionDef):
                        user_defined.add(node.name)
                    elif isinstance(node, ast.Assign):
                        for target in node.targets:
                            if isinstance(target, ast.Name):
                                user_defined.add(target.id)
                            # Tuple unpacking? (a, b) = ...
                            elif isinstance(target, ast.Tuple) or isinstance(target, ast.List):
                                for elt in target.elts:
                                    if isinstance(elt, ast.Name):
                                        user_defined.add(elt.id)

                # 2. Transform AST
                transformer = P5Transformer(user_defined, case_mode)
                new_tree = transformer.visit(tree)
                ast.fix_missing_locations(new_tree)

                # 3. Compile and Execute
                try:
                    code_obj = compile(new_tree, filename="sketch.py", mode="exec")
                    exec(code_obj, globals())
                except Exception as e:
                    import traceback
                    import os
                    
                    err_msg = f"{e.__class__.__name__}: {e}"
                    line_num = 0
                    err_filename = "sketch.py"

                    if isinstance(e, SyntaxError):
                         err_msg = f"{e.__class__.__name__}: {e.msg}"
                         line_num = e.lineno
                         err_filename = e.filename
                    else:
                        tb_list = traceback.extract_tb(e.__traceback__)
                        # Find the last frame that is in a user file or sketch.py
                        for frame in tb_list:
                            if frame.filename == "sketch.py" or os.path.exists(frame.filename):
                                err_filename = frame.filename
                                line_num = frame.lineno
                    
                    msg = {"type": "error", "message": err_msg, "filename": err_filename, "line": line_num}
                    js.window.parent.postMessage(to_js(msg, dict_converter=js.Object.fromEntries), "*")
                    return
                
                # 4. Connect to p5
                # List of p5.js event functions to map
                p5_events = [
                    'setup', 'draw', 'preload',
                    'mousePressed', 'mouseReleased', 'mouseClicked', 'mouseMoved', 'mouseDragged', 'doubleClicked', 'mouseWheel',
                    'keyPressed', 'keyReleased', 'keyTyped',
                    'touchStarted', 'touchMoved', 'touchEnded',
                    'deviceMoved', 'deviceTurned', 'deviceShaken',
                    'windowResized'
                ]
                
                import inspect
                import traceback

                def safe_wrapper(func):
                    def wrapper(*args, **kwargs):
                        try:
                            return func(*args, **kwargs)
                        except Exception:
                            traceback.print_exc() 
                            # Stop the sketch loop on error
                            if P5:
                                P5.noLoop()
                    return wrapper

                def create_arg_stripper(func):
                    return lambda *args: func()

                for event in p5_events:
                    py_func = None
                    
                    # 1. Check for standard camelCase (mousePressed)
                    if event in globals():
                        py_func = globals()[event]
                        
                    # 2. Check for snake_case (mouse_pressed)
                    else:
                        snake_event = camel_to_snake(event)
                        if snake_event != event and snake_event in globals():
                            py_func = globals()[snake_event]
                    
                    if py_func:
                        # Handle argument mismatch (e.g. mousePressed(e) vs mousePressed())
                        if callable(py_func):
                             try:
                                 sig = inspect.signature(py_func)
                                 params = sig.parameters
                                 has_varargs = any(p.kind == p.VAR_POSITIONAL for p in params.values())
                                 
                                 if not has_varargs and len(params) == 0:
                                      # Wrap to discard arguments
                                      py_func = create_arg_stripper(py_func)
                             except Exception as e:
                                 pass

                        # Wrap in error handler
                        secure_func = safe_wrapper(py_func)
                        setattr(p, event, create_proxy(secure_func))

            proxy = create_proxy(sketch)
            js.window.p5.new(proxy)

        import asyncio
        asyncio.ensure_future(entry_point())
    </script>
</body>
</html>
